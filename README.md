### Висновки щодо ефективності алгоритмів

#### 1. Жадібний алгоритм (`find_coins_greedy`)
- Використовує найбільші номінали першочергово.
- **Час виконання**: `1.907` сек.
- **Результат для суми 113**: `{50: 2, 10: 1, 2: 1, 1: 1}`.
- Простий у реалізації, працює швидко для стандартних номіналів монет.

#### 2. Динамічне програмування (`find_min_coins`)
- Знаходить мінімальну кількість монет для суми.
- **Час виконання**: `3.027` сек.
- **Результат для суми 113**: `{1: 1, 2: 1, 10: 1, 50: 2}`.
- Забезпечує оптимальне розбиття, але вимагає більше обчислень.

### Порівняння

| Алгоритм | Час виконання (сек) | Результат | Оптимальність |
|----------|---------------------|-----------|---------------|
| **Жадібний** | `1.907` | `{50: 2, 10: 1, 2: 1, 1: 1}` | Не завжди оптимальний |
| **Динамічне програмування** | `3.027` | `{1: 1, 2: 1, 10: 1, 50: 2}` | Гарантовано оптимальний |

### Висновки
- **Жадібний алгоритм швидший**, але не завжди дає мінімальну кількість монет.
- **Алгоритм динамічного програмування повільніший**, але завжди дає оптимальний набір монет.
- **При великих сумах** жадібний алгоритм може бути ефективнішим, якщо набір номіналів дозволяє отримувати мінімальну кількість монет.
- **Динамічне програмування потрібне, коли важлива мінімізація кількості монет**, а не просто швидке рішення.
